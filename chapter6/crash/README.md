CRASH

crash is a quick demonstration program showing how reusing challenges in
a challenge response system compromises its security. There are four
components: the server, the legitimate client (which needs the password),
a sniffer to grab challenges and their responses, and rogue, the rogue
client that doesn't need a password. The server has been modified to use
an 8-bit challenge instead of the 64-bit one used in the book.

To build the sniffer, you will need libpcap. Running the sniffer will
most likely require root (or administrative) privileges to listen on
the network interface, just as with the `tcpdump` program.

To see it in action, start up the server. Then, fire up the sniffer.
At any point, after this, you can fire up the rogue client. Make sure to
pass it the database generated by the sniffer and the server's address, i.e.

        rogue/rogue -d sniffer/challenges.db 127.0.0.1:4141

It won't know any of the challenges, so it will continually fail to
autenticate. Then, start running the legitimate client. Try doing

        for i in $(seq 1 100)
        do
                client/client -a 127.0.0.1:4141 -p <password>
        done

You should start to see the sniffer reporting the challenges it has
grabbed. At some point, you should see the message

        [+] found reused challenge <some number>

At some point after this, the rogue client should connect. Note that
the rogue client has no knowledge of the password; it is just sending
pre-recorded responses. This highlights the dangers of reusing challenges
in a challenge-response authentication scheme.
